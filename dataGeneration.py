import numpy as np
import cv2
import glob

class DataSet:
    """
    This is the class that generates & modifying the data
    1.Positive samples are generated by a rectangle that 1/3 padding of the ellipse
    2.Negative samples are generated either by original image or 1/3 padding of rectangle
    3.Using the first 8 files' images as training set and the final 2 as testing set

    """
    def __init__(self, filepath):
        self.filepath = filepath
        self.paths = glob.glob(pathname=filepath+"FDDB-fold-**-ellipseList.txt")

    def generatePositive(self, dataPath, outPath):
        """
        Generating positive samples by adding the correct rectangle to the picutre
        Each rectangle is 1/3 padding out of the ellipse
        Using only 8 of the total folds to generate positive samples
        If the rectangle outside the image padding 1/3 as the neareast pixel

        """
        print(self.paths)
        for i in range(8):
            file = open(self.paths[i], 'r')
            # read the image file path
            line = file.readline()
            while (line):
                image = cv2.imread(dataPath + line[:-1] + ".jpg")
                print("Processing " + dataPath + line[:-1] + ".jpg")

                # read how many faces are there in the picuture
                faces = int(file.readline())
                for j in range(faces):
                    line = file.readline()
                    line = line.split(' ')
                    long, short, angle, center_x, center_y = line[:5]

                    # Calculating the points and getting the rectangle on the image
                    width = float(short) * 8 / 3
                    height = float(long) * 8 / 3
                    center_x = float(center_x)
                    center_y = float(center_y)

                    image = cv2.rectangle(image, pt1=(int(center_x - width / 2), int(center_y - height / 2)), pt2=(int(center_x + width / 2), int(center_y + height / 2)), color=(0,0,255))
                    # Now deal with the situation when the rectangle is outside the image
                    output = image[max(int(center_y - height / 2), 0):min(int(center_y + height / 2), image.shape[0]),
                                   max(0, int(center_x - width / 2)):min(int(center_x + width / 2), image.shape[1])]
                    if center_x - width / 2 < 0:
                        for k in range(int(width / 2 - center_x)):
                            output = np.insert(output, 0, output[0, :], axis=0)
                    if center_x + width / 2 > image.shape[1]:
                        for k in range(int(center_x + width / 2 - image.shape[1])):
                            output = np.insert(output, -1, output[-1, :], axis=0)
                    if center_y - height / 2 < 0:
                        for k in range(int(height / 2 - center_y)):
                            output = np.insert(output, 0, output[:, 0], axis=1)
                    if center_y + height / 2 > image.shape[0]:
                        for k in range(int(center_y + height / 2 - image.shape[0])):
                            output = np.insert(output, -1, output[:, -1], axis=1)
                    cv2.imshow("output", output)
                    cv2.waitKey(0)
                # cv2.imshow("output", image)
                # cv2.waitKey(0)
                line = file.readline()

if __name__ == "__main__":
    d = DataSet("./FDDB-folds/")
    d.generatePositive("./originalPics/", "")
